---
title: "MSB1015 Scientific Programming: Assignment 2"
author: "Lian Laudy"
date: "5 oktober 2018"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Packages

Check if the required packages are already installed. If not, install them:
```{r}
packages = c("matrixStats", "Boruta", "pls", "ggplot2")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packages, rownames(installed.packages())))  
}
```

Load the required packages:
```{r}
# the package 'matrixStats' is used to calculate the variance across each column (descriptor)
library(matrixStats)
# the package 'Boruta' is used to perform feature selection based on a Random Forest method
library(Boruta)
# the package 'pls' is used to perfrom the Partial Least Squares analysis
library(pls)
# the package 'ggplot2' is used to plot the observed and predicted activity scores
library(ggplot2)
```

# Load data

Load the data files.
The data file called 'score' has to contain the 'SID' in the first column and the Activity Score in the second column.
The data file called 'descriptors' has to contain the 'SID' in the first column and the descriptors in the remaining columns. 
```{r}
score = read.csv(file = 'C:/Users/Lian/Desktop/CloudStation/MSB1015 Scientific Programming/Assignments/2 Making multivariate statistics reproducible/qsarSmallData.csv', sep=',', row.names = 1, header=TRUE)

descriptors = read.csv(file = 'C:/Users/Lian/Desktop/CloudStation/MSB1015 Scientific Programming/Assignments/2 Making multivariate statistics reproducible/descriptors.csv', sep=',', row.names = 1, header=TRUE)
```
Sort both dataframes by substance ID such that the order of molecules matches:
```{r}
score = score[order(score$SID),]
row.names(score) = c(1:nrow(score))
descriptors =  descriptors[order(descriptors$molSIDs),]
row.names(descriptors) = c(1:nrow(descriptors))

#check if sorting went well:
table(score[,1] == descriptors[,1])
```
# Split data

Create a training set (80%) and a test set (20%):  
```{r}
# use set.seed() to ensure that the same random numbers are used and the results are reproducible
set.seed(0)
# selected 80% of the total number of rows
selection = sample(nrow(descriptors), 0.8*nrow(descriptors))
# use this selection to select the training data
score_tr = score[selection, ]
descs_tr = descriptors[selection, ]
# the same selection will be excluded from the test data
score_te = score[-selection, ]
descs_te = descriptors[-selection, ]
```
# Data cleaning

The training data contains many Na values:
```{r}
table(is.na(descs_tr))
table(colSums(is.na(descs_tr)))
```

Remove descriptors (columns) that contain at least one missing value:
```{r}
# we only include the columns in which the number of row that do NOT contain missing values is equal to the total number of rows
descs_tr = descs_tr[,colSums(!is.na(descs_tr)) == nrow(descs_tr)]
```
# Feature selection (based on variance)
In order to reduce the number of descriptors, we selected descriptors based on their variance.
Only descriptors with a variance higher than the third quantile were selected.
```{r}
# Compute for each descriptor the variance (except column 1 which contains the molecule ID):
variance_tr = colVars(as.matrix(descs_tr[,2:length(descs_tr)]))
summary(variance_tr)

# Calculate the value of the third quantile of the variance:
quantile75 = quantile(variance_tr, .75)

# Select only the descriptors with a variance higher than the third quantile (plus the first column containing the molecule ID):
descs_tr = descs_tr[,c(TRUE, (variance_tr > quantile75))]

# Number of removed descriptors based on variance:
(length(variance_tr)+1)-ncol(descs_tr)

# Number of included descriptors (excluding the molecule ID):
ncol(descs_tr)-1
```
# Data transformation
The data is scaled in order to standardize the range of the descriptors.  
```{r}
# Calculate the mean of each descriptor in the training set:
mean_descriptor = colMeans(descs_tr[,2:length(descs_tr)])
  
# Calculate the standard deviation of each descriptor in the training set:
sd_descriptor = apply(as.matrix(descs_tr[,2:length(descs_tr)]), 2, sd)
  
# Normalize each descriptor in the training set:
descs_tr_norm = as.data.frame(array(data = NA, dim = c(nrow(descs_tr),ncol(descs_tr))))
descs_tr_norm[,1] =  descs_tr[,1]
colnames(descs_tr_norm) = colnames(descs_tr)

for (j in 2:ncol(descs_tr_norm)) { 
    descs_tr_norm[,j] = (descs_tr[,j] - mean_descriptor[j-1]) / sd_descriptor[j-1]
}


```


